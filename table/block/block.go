package block

import (
	"encoding/binary"
	"go-lsm/kv"
)

// Block represents the in-memory representation of Block.
//
// Each block contains encoded key/value pairs, and keyValueBeginOffsets. The reason for storing keyValueBeginOffsets is to allow
// binary search for a key within a block.
type Block struct {
	data                 []byte
	keyValueBeginOffsets []uint16
	lastDataIndex        int
}

// newBlock creates a new instance of Block.
// data is the encoded key/value pairs generated by block.Builder.
func newBlock(data []byte, lastDataIndex int, keyValueBeginOffsets []uint16) Block {
	return Block{
		data:                 data,
		keyValueBeginOffsets: keyValueBeginOffsets,
		lastDataIndex:        lastDataIndex,
	}
}

// Encode encodes the block to byte slice.
/*
// blocking encoding looks like the following:
  -------------------------------------------------------------------------------------------------------------------------------------------------
 | encoded key/value  | encoded key/value  |....| encoded key/value  | 0 | 48 | 120 | ...... |3088|      2 bytes          |          2 bytes       |
  -------------------------------------------------------------------------------------------------------------------------------------------------
  <--------------------------Encoded data---------------------------><-- Begin offsets of keys --><-- Start of offsets --><-Number of begin offsets->
*/
func (block Block) Encode() []byte {
	data := block.data
	copy(data[block.lastDataIndex:], block.encodeKeyValueBeginOffsets())

	binary.LittleEndian.PutUint16(data[len(data)-Uint16Size:], uint16(len(block.keyValueBeginOffsets)))
	binary.LittleEndian.PutUint16(data[len(data)-Uint16Size-Uint16Size:], uint16(block.lastDataIndex))

	return data
}

// DecodeToBlock decodes the given byte slice to the Block.
//
// The last 2 bytes denote the number of keyValueBeginOffsets.
// The 2 bytes prior to the last 2 bytes denote the start offset of keyValueBeginOffsets.
func DecodeToBlock(data []byte) Block {
	numberOfOffsets := binary.LittleEndian.Uint16(data[len(data)-Uint16Size:])
	startOfOffsets := binary.LittleEndian.Uint16(data[len(data)-Uint16Size-Uint16Size:])
	offsetsBuffer := data[startOfOffsets : startOfOffsets+numberOfOffsets*uint16(Uint16Size)]

	keyValueBeginOffsets := make([]uint16, 0, numberOfOffsets)
	for index := 0; index < len(offsetsBuffer); index += Uint16Size {
		keyValueBeginOffsets = append(keyValueBeginOffsets, binary.LittleEndian.Uint16(offsetsBuffer[index:]))
	}
	return Block{
		data:                 data[:startOfOffsets],
		keyValueBeginOffsets: keyValueBeginOffsets,
	}
}

// SeekToFirst creates an iterator (/block iterator) that is positioned at the first offset in the block.
func (block Block) SeekToFirst() *Iterator {
	iterator := &Iterator{
		block:       block,
		offsetIndex: 0,
	}
	iterator.seekToOffsetIndex(iterator.offsetIndex)
	return iterator
}

// SeekToKey creates an iterator (/block iterator) that is positioned at a key which is greater or equal to the given key.
func (block Block) SeekToKey(key kv.Key) *Iterator {
	iterator := &Iterator{
		block: block,
	}
	iterator.seekToGreaterOrEqual(key)
	return iterator
}

// encodeKeyValueBeginOffsets encodes all the keyValueBeginOffsets to byte slice using LittleEndian encoding.
func (block Block) encodeKeyValueBeginOffsets() []byte {
	offsetBuffer := make([]byte, Uint16Size*len(block.keyValueBeginOffsets))
	offsetIndex := 0
	for _, offset := range block.keyValueBeginOffsets {
		binary.LittleEndian.PutUint16(offsetBuffer[offsetIndex:], offset)
		offsetIndex += Uint16Size
	}
	return offsetBuffer
}
